# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов
# класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки
# первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.


class Matrix:
    def __init__(self, list_a, list_b):
        self.list_a = list_a
        self.list_b = list_b

    def __add__(self):
        matrix = [[0, 0, 0, 0],
                  [0, 0, 0, 0],
                  [0, 0, 0, 0],
                  [0, 0, 0, 0]]

        for i in range(len(self.list_a)):

                for el in range(len(self.list_b[i])):
                    matrix[i][el] = self.list_a[i][el] + self.list_b[i][el]

        return str('\n'.join(['\t'.join([str(el) for el in i]) for i in matrix]))


my_matrix = Matrix([[4, 10, 32, 45],
                    [5, 16, 22, 9],
                    [36, 17, 4, 8],
                    [87, 46, 13, 73]],
                   [[5, 7, 8, 45],
                    [35, 74, 8, 21],
                    [57, 50, 43, 10],
                    [7, 34, 6, 9]])

print(my_matrix.__add__())


# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры:
# размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5),
# для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.


class Clothes:
    def __init__(self, v, h):
        self.v = v
        self.h = h

    def coat(self):
        return self.v / 6.5 + 0.5

    def costume(self):
        return self.h * 2 + 0.3

    @property
    def cloth(self):
        return str(f'Расход ткани: {round((self.v / 6.5 + 0.5) + (self.h * 2 + 0.3))}')


class Coat(Clothes):
    def __init__(self, v, h):
        super().__init__(v, h)
        self.cloth_coat = round(self.v / 6.5 + 0.5)

    def __str__(self):
        return f'Расход ткани для пальто: {self.cloth_coat}'


class Costume(Clothes):
    def __init__(self, v, h):
        super().__init__(v, h)
        self.cloth_costume = round(self.h * 2 + 0.3)

    def __str__(self):
        return f'Расход ткани для костюма: {self.cloth_costume}'


coat = Coat(38, 1.76)
costume = Costume(38, 1.76)
print(coat)
print(costume)
print(coat.cloth)


# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# обычное (не целочисленное) деление клеток, соответственно.
# В методе деления должно осуществляться округление значения до целого числа.
# Сложение. Объединение двух клеток.
# При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность
# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух.
# Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух.
# Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****...,где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку:
# *****\n*****\n*****.


class Cell:
    def __init__(self, number):
        self.number = int(number)

    def __str__(self):
        return f'Результат {self.number * "*"}'

    def __add__(self, other):
        return Cell(self.number + other.number)

    def __sub__(self, other):
        if (self.number - other.number) > 0:
            return Cell(self.number - other.number)
        else:
            print('Отрицательное количество')

    def __mul__(self, other):
        return Cell(int(self.number * other.number))

    def __truediv__(self, other):
        return Cell(round(self.number // other.number))

    def make_order(self, cells):
        row = ''
        for i in range(int(self.number / cells)):
            row += f'{"*" * cells}\\n'
        row += f'{"*" * (self.number % cells)}'
        return row


cell_1 = Cell(28)
cell_2 = Cell(15)
print(cell_1)
print(cell_1 + cell_2)
print(cell_1 - cell_2)
print(cell_2 - cell_1)
print(cell_1 * cell_2)
print(cell_2.make_order(6))
print(cell_1.make_order(10))
